name: Webhook Notification

on:
  schedule:
    # æ¯5åˆ†é˜åŸ·è¡Œä¸€æ¬¡ï¼Œèˆ‡ uptime æª¢æŸ¥åŒæ­¥
    - cron: "*/5 * * * *"
  workflow_dispatch:
  repository_dispatch:
    types: [webhook-notify]

jobs:
  webhook-notify:
    name: Send Webhook Notifications
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GH_PAT || github.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Send webhook notifications
        env:
          WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
          WEBHOOK_TYPE: ${{ secrets.WEBHOOK_TYPE || 'slack' }}
        run: |
          # å‰µå»ºç°¡åŒ–çš„ webhook ç™¼é€è…³æœ¬
          cat > webhook-sender.js << 'EOF'
          const https = require('https');
          const http = require('http');

          const config = {
            webhookUrl: process.env.WEBHOOK_URL,
            webhookType: process.env.WEBHOOK_TYPE || 'slack'
          };

          if (!config.webhookUrl) {
            console.log('âš ï¸ WEBHOOK_URL æœªè¨­å®šï¼Œè·³éŽé€šçŸ¥');
            process.exit(0);
          }

          // è®€å– API æ•¸æ“š
          function readJsonFile(filePath) {
            try {
              const fs = require('fs');
              return JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (error) {
              return null;
            }
          }

          // ç™¼é€ webhook
          async function sendWebhook(payload) {
            const url = new URL(config.webhookUrl);
            const options = {
              hostname: url.hostname,
              port: url.port || (url.protocol === 'https:' ? 443 : 80),
              path: url.pathname + url.search,
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(payload)
              }
            };

            return new Promise((resolve, reject) => {
              const client = url.protocol === 'https:' ? https : http;
              const req = client.request(options, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => {
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    resolve(data);
                  } else {
                    reject(new Error(`HTTP ${res.statusCode}: ${data}`));
                  }
                });
              });

              req.on('error', reject);
              req.write(payload);
              req.end();
            });
          }

          // ç”Ÿæˆ Slack æ ¼å¼çš„ payload
          function generateSlackPayload(siteName, siteUrl, responseTime, uptime) {
            const isUp = true; // å‡è¨­ç‚ºæ­£å¸¸ç‹€æ…‹ï¼Œå› ç‚ºæª”æ¡ˆå­˜åœ¨è¡¨ç¤ºæœå‹™æ­£å¸¸
            const statusEmoji = 'ðŸŸ¢';
            const statusText = 'æ­£å¸¸é‹è¡Œ';

            return JSON.stringify({
              attachments: [{
                color: 'good',
                title: `${statusEmoji} ${siteName} - ${statusText}`,
                title_link: siteUrl,
                fields: [
                  {
                    title: 'ç‹€æ…‹',
                    value: statusText,
                    short: true
                  },
                  {
                    title: 'éŸ¿æ‡‰æ™‚é–“',
                    value: `${responseTime}ms`,
                    short: true
                  },
                  {
                    title: 'é‹è¡Œæ™‚é–“',
                    value: uptime,
                    short: true
                  },
                  {
                    title: 'æª¢æŸ¥æ™‚é–“',
                    value: new Date().toLocaleString('zh-TW'),
                    short: true
                  }
                ],
                footer: 'Upptime ç›£æŽ§ç³»çµ±',
                ts: Math.floor(Date.now() / 1000)
              }]
            });
          }

          // ä¸»å‡½æ•¸
          async function main() {
            const sites = [
              {
                name: 'our_api ä¸»è¦è³‡æ–™ (è³‡æ–™ä¾†æº)',
                url: 'https://bvc-api.deno.dev',
                apiPath: 'api/our-api'
              },
              {
                name: 'moa_api è¾²æ¥­éƒ¨è³‡æ–™ (å‰¯è³‡æ–™ä¾†æº)',
                url: 'https://data.moa.gov.tw/Service/OpenData/FromM/FarmTransData.aspx',
                apiPath: 'api/moa-api'
              },
              {
                name: 'notify_api é€šçŸ¥é é¢ (é€šçŸ¥å…§å®¹)',
                url: 'https://bvcaanotify.deno.dev',
                apiPath: 'api/notify-api'
              }
            ];

            for (const site of sites) {
              try {
                const responseTimeData = readJsonFile(`${site.apiPath}/response-time.json`);
                const uptimeData = readJsonFile(`${site.apiPath}/uptime.json`);

                if (responseTimeData && uptimeData) {
                  const responseTime = responseTimeData.message.replace(' ms', '');
                  const uptime = uptimeData.message;

                  const payload = generateSlackPayload(site.name, site.url, responseTime, uptime);
                  await sendWebhook(payload);
                  
                  console.log(`âœ… ${site.name} é€šçŸ¥ç™¼é€æˆåŠŸ`);
                } else {
                  console.log(`âš ï¸ ${site.name} æ•¸æ“šæª”æ¡ˆä¸å­˜åœ¨ï¼Œè·³éŽé€šçŸ¥`);
                }
              } catch (error) {
                console.error(`âŒ ${site.name} é€šçŸ¥ç™¼é€å¤±æ•—:`, error.message);
              }
            }
          }

          main().catch(console.error);
          EOF

          # åŸ·è¡Œ webhook ç™¼é€
          node webhook-sender.js
